# Web Components Package Design

## Context

The team wants to publish the standalone collection of native Web Components that currently live in this repository in a way that is compatible with both browser-based consumers (via ES modules) and Node/CommonJS tooling. The package should sit alongside the existing React component package while keeping the delivery footprint small and allowing downstream applications to opt into custom element registration behavior that best fits their bootstrapping model.

## Goals

- Establish the package metadata and directory layout before any implementation work begins.
- Align on the module formats, type distribution, and npm metadata required for dual ESM/CJS publication.
- Document the public API so that both framework and non-framework consumers understand how to load and register the elements.

## Decisions

### Package identity and location

- **npm package name:** `@wavelengthusaf/web-components`
  - Mirrors the existing `@wavelengthusaf/components` namespace while signalling that this package exports Custom Elements rather than React components.
- **Workspace directory:** `apps/packages/web-components`
  - Keeps the new package colocated with the current component package and testbed under the monorepo's `apps/packages/` root, simplifying workspace management.
- **Entry strategy:** Manual exports from `src/index.ts` plus an optional auto-registration helper in `src/register.ts`.
  - `src/index.ts` will explicitly export each element class (e.g., `SampleComponentElement`) and any helper types. This keeps tree-shaking effective and lets consumers register only the elements they need.
  - `src/register.ts` will expose a `registerAll()` side-effect function that iterates over available elements and calls `customElements.define`. Bundlers can reference `@wavelengthusaf/web-components/register` when they prefer automatic registration.

### `package.json` blueprint

The package manifest will include the following key fields:

| Field | Value / Notes |
| --- | --- |
| `name` | `@wavelengthusaf/web-components` |
| `version` | Managed independently (starts at `0.1.0` when first published). |
| `description` | "Custom Elements published by the Wavelength team for framework-agnostic reuse." |
| `author` / `license` | Reuse values from the existing package (`563 EWS - Wavelength`, `MIT`). |
| `type` | `module` (so relative `import` paths resolve as ESM by default). |
| `main` | `./dist/cjs/index.cjs` for CommonJS consumers. |
| `module` | `./dist/esm/index.js` for bundlers using native ESM. |
| `types` | `./dist/types/index.d.ts` (emitted by TypeScript). |
| `exports` | Conditional exports map with entries for `.` (default), `./register`, and `./package.json` to direct importers to the proper format/type files. |
| `files` | `dist/**/*`, `README.md`, `CHANGELOG.md` (keep publish footprint small). |
| `scripts` | `build`, `build:esm`, `build:cjs`, `build:types`, `lint`, `test`, mirroring the existing package but scoped to this workspace. |
| `peerDependencies` | `lit` or other shared runtime libraries if introduced; otherwise keep empty to reduce install surface. |
| `devDependencies` | `tsup`, `typescript`, testing utilities, and any tooling needed for compiling vanilla web components. |

- **Build tooling:** Reuse [`tsup`](https://tsup.egoist.dev) with a dedicated configuration file (`apps/packages/web-components/tsup.config.ts`). The existing component package already ships with tsup, so keeping the same bundler minimizes new dependencies, ensures consistent output defaults (sourcemaps, `es2020` target, tree shaking), and lets us share knowledge across packages. The new config will export an array of two builds—one for ESM and one for CJS—each with explicit entry maps for `index` and `register`. A lightweight `tsconfig.build.json` scoped to the workspace will run `tsc --emitDeclarationOnly` so we can control declaration output separately from bundling.

### Build outputs

All compiled artefacts for the standalone package will live under `apps/packages/web-components/dist` using the same top-level folders across formats so CI and Storybook jobs can address them deterministically:

- **ESM bundle:** `apps/packages/web-components/dist/esm/index.js` and `apps/packages/web-components/dist/esm/register.js`, generated by `tsup`'s ESM build. Sourcemaps will sit alongside the bundles (e.g., `index.js.map`).
- **CJS bundle:** `apps/packages/web-components/dist/cjs/index.cjs` and `apps/packages/web-components/dist/cjs/register.cjs`, generated by the second `tsup` build target.
- **Type declarations:** `apps/packages/web-components/dist/types/**/*.d.ts` emitted by `tsc --project tsconfig.build.json --emitDeclarationOnly`. This keeps `"types": "./dist/types/index.d.ts"` stable even if bundle folder names change.
- **Helper index for Storybook:** Storybook can import from `@wavelengthusaf/web-components/register` and rely on the artefacts above. No additional CDN bundle is produced initially; if needed later we can add `dist/standalone/` without disrupting existing jobs.
- **Static assets (future optional):** Should a web component require CSS or fonts, mirror the React package's approach with `apps/packages/web-components/dist/assets/<type>` so both packages follow the same naming convention. CI steps can glob `apps/**/dist/assets/**` when publishing.

### npm scripts

To keep package-level workflows scoped while still enabling cross-repo builds, add the following scripts:

**Root `package.json`**

- `"build:web"`: `cd apps/packages/web-components && npm run build` – triggers the workspace build.【F:package.json†L34-L35】
- `"build:packages"`: `npm run build:web && npm run build:react` – orchestrates every artefact needed for release pipelines.【F:package.json†L33-L35】
- (Optional) `"watch:web"`: `cd apps/packages/web-components && npm run watch` keeps parity with the existing watch helper.【F:package.json†L29-L30】

**`apps/packages/web-components/package.json`**

- `"build"`: `npm run build:esm && npm run build:cjs` – runs both bundling targets sequentially.【F:apps/packages/web-components/package.json†L22-L26】
- `"build:esm"`: `tsup src/index.ts --format esm --dts --outDir dist/esm && mkdir -p dist/styles/ dist/fonts && cp -R src/styles/ dist/styles/ && cp -R src/fonts/ dist/fonts/` – emits the ESM bundle and declaration files.【F:apps/packages/web-components/package.json†L22-L24】
- `"build:cjs"`: `tsup src/index.ts --format cjs --outDir dist/cjs && mkdir -p dist/styles/ dist/fonts && cp -R src/styles/ dist/styles/ && cp -R src/fonts/ dist/fonts/` – emits the CommonJS build.【F:apps/packages/web-components/package.json†L24-L25】
- `"watch"`: `concurrently -k "npm run watch:esm" "npm run watch:cjs"` – runs both watch modes together.【F:apps/packages/web-components/package.json†L27-L29】
- `"watch:esm"` / `"watch:cjs"`: Keep parity with the build commands while enabling incremental rebuilds.【F:apps/packages/web-components/package.json†L26-L28】
- `"compile"`, `"lint"`, and `"test"` map to TypeScript, ESLint, and Jest workflows scoped to this workspace.【F:apps/packages/web-components/package.json†L18-L23】

### Public API surface

- **Named exports** from `src/index.ts` for each custom element class (e.g., `SampleComponentElement`, `BadgeElement`, etc.). These classes extend `HTMLElement` and let consumers register them manually.
- **Utility exports** like `registerSampleComponent()` when a component needs custom registration logic (for instance, differing tag names). These functions wrap `customElements.define` and enforce one-time registration guards.
- **`registerAll()` helper** from `src/register.ts` that registers every element exposed by the package. Importers can call `import { registerAll } from "@wavelengthusaf/web-components/register"; registerAll();` to eagerly define everything.
- **Type exports** for component-specific attribute interfaces (e.g., `SampleComponentAttributes`) so TypeScript consumers can type-check attribute bags when interacting with elements programmatically.
- **No default export** to keep the surface explicit and avoid bundler ambiguity between formats.

## Open questions / Follow-up items

- Confirm whether any shared base classes or mixins will live in this package or continue to live alongside React components.
- Determine if a CDN-friendly self-registering bundle is necessary for script-tag usage; if so, we can add an additional `dist/standalone` artifact in a future iteration.
- Decide on integration testing strategy (Playwright vs. Web Test Runner) once the elements are implemented.
